```yaml
name: Setup BeenCoin Project

on:
  workflow_dispatch:  # ìˆ˜ë™ ì‹¤í–‰ ê°€ëŠ¥
  push:
    branches: [ main ]

jobs:
  setup-project:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Create project structure
      run: |
        # í´ë” êµ¬ì¡° ìƒì„±
        mkdir -p app/{core,api/v1/endpoints,models,services,utils,schemas,routers} tests
        mkdir -p .github/workflows
        
        # requirements.txt ìƒì„±
        cat > requirements.txt << 'EOF'
        fastapi==0.104.1
        uvicorn==0.24.0
        sqlalchemy==2.0.23
        sqlmodel==0.0.11
        pydantic==2.5.0
        python-jose==3.3.0
        passlib==1.7.4
        bcrypt==4.0.1
        python-multipart==0.0.6
        httpx==0.25.2
        websockets==12.0
        redis==5.0.1
        aioredis==2.0.1
        pytest==7.4.3
        pytest-asyncio==0.21.1
        aiohttp==3.9.1
        celery==5.3.4
        python-binance==1.0.19
        python-dotenv==1.0.0
        EOF
        
        # .env.example ìƒì„±
        cat > .env.example << 'EOF'
        DATABASE_URL=sqlite+aiosqlite:///./beencoin.db
        SECRET_KEY=your-secret-key-change-in-production
        BINANCE_API_KEY=your-binance-api-key
        BINANCE_API_SECRET=your-binance-api-secret
        EOF
        
        # app/core/config.py ìƒì„±
        mkdir -p app/core
        cat > app/core/config.py << 'EOF'
        from pydantic_settings import BaseSettings
        from typing import Optional
        from dotenv import load_dotenv
        import os

        load_dotenv()

        class Settings(BaseSettings):
            API_V1_STR: str = "/api/v1"
            PROJECT_NAME: str = "BeenCoin API"
            DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./beencoin.db")
            SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
            ALGORITHM: str = "HS256"
            ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
            BINANCE_API_URL: str = "https://api.binance.com/api/v3"
            BINANCE_API_KEY: Optional[str] = os.getenv("BINANCE_API_KEY")
            BINANCE_API_SECRET: Optional[str] = os.getenv("BINANCE_API_SECRET")
            REDIS_URL: str = "redis://localhost:6379"
            INITIAL_BALANCE: float = 1000000

            class Config:
                case_sensitive = True

        settings = Settings()
        EOF
        
        # app/models/database.py ìƒì„±
        mkdir -p app/models
        cat > app/models/database.py << 'EOF'
        from sqlmodel import SQLModel, Field, Relationship, create_engine
        from typing import Optional, List
        from datetime import datetime
        from decimal import Decimal

        class User(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            username: str = Field(unique=True, index=True)
            hashed_password: str
            created_at: datetime = Field(default_factory=datetime.utcnow)
            accounts: List["TradingAccount"] = Relationship(back_populates="user")
            orders: List["Order"] = Relationship(back_populates="user")

        class TradingAccount(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            user_id: int = Field(foreign_key="user.id")
            balance: Decimal = Field(default=1000000, max_digits=20, decimal_places=8)
            total_profit: Decimal = Field(default=0, max_digits=20, decimal_places=8)
            user: User = Relationship(back_populates="accounts")
            positions: List["Position"] = Relationship(back_populates="account")

        class Order(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            user_id: int = Field(foreign_key="user.id")
            symbol: str
            side: str  # 'buy' or 'sell'
            order_type: str  # 'market' or 'limit'
            order_status: str = "pending"
            price: Optional[Decimal] = Field(default=None, max_digits=20, decimal_places=8)  # for limit orders
            quantity: Decimal = Field(max_digits=20, decimal_places=8)
            filled_quantity: Decimal = Field(default=0, max_digits=20, decimal_places=8)
            created_at: datetime = Field(default_factory=datetime.utcnow)
            updated_at: datetime = Field(default_factory=datetime.utcnow)
            user: User = Relationship(back_populates="orders")

        class Position(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            account_id: int = Field(foreign_key="tradingaccount.id")
            symbol: str
            quantity: Decimal = Field(max_digits=20, decimal_places=8)
            average_price: Decimal = Field(max_digits=20, decimal_places=8)
            current_value: Decimal = Field(max_digits=20, decimal_places=8)
            unrealized_profit: Decimal = Field(default=0, max_digits=20, decimal_places=8)
            account: TradingAccount = Relationship(back_populates="positions")

        def create_db_and_tables():
            engine = create_engine(settings.DATABASE_URL)
            SQLModel.metadata.create_all(engine)
        EOF
        
        # app/schemas/user.py ìƒì„±
        mkdir -p app/schemas
        cat > app/schemas/user.py << 'EOF'
        from pydantic import BaseModel

        class UserCreate(BaseModel):
            username: str
            password: str

        class UserLogin(BaseModel):
            username: str
            password: str

        class UserOut(BaseModel):
            id: int
            username: str
        EOF
        
        # app/schemas/order.py ìƒì„±
        cat > app/schemas/order.py << 'EOF'
        from pydantic import BaseModel
        from decimal import Decimal
        from typing import Optional

        class OrderCreate(BaseModel):
            symbol: str
            side: str  # 'buy' or 'sell'
            order_type: str  # 'market' or 'limit'
            quantity: Decimal
            price: Optional[Decimal] = None  # for limit orders

        class OrderOut(BaseModel):
            id: int
            symbol: str
            side: str
            order_type: str
            status: str
            quantity: Decimal
            filled_quantity: Decimal
            price: Optional[Decimal]
        EOF
        
        # app/schemas/account.py ìƒì„±
        cat > app/schemas/account.py << 'EOF'
        from pydantic import BaseModel
        from decimal import Decimal
        from typing import List

        class PositionOut(BaseModel):
            symbol: str
            quantity: Decimal
            average_price: Decimal
            current_value: Decimal
            unrealized_profit: Decimal

        class AccountOut(BaseModel):
            balance: Decimal
            total_profit: Decimal
            positions: List[PositionOut]
            profit_rate: Decimal  # ìˆ˜ìµë¥  (%)
        EOF
        
        # app/utils/security.py ìƒì„±
        mkdir -p app/utils
        cat > app/utils/security.py << 'EOF'
        from passlib.context import CryptContext
        from jose import JWTError, jwt
        from datetime import datetime, timedelta
        from app.core.config import settings

        pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

        def verify_password(plain_password, hashed_password):
            return pwd_context.verify(plain_password, hashed_password)

        def get_password_hash(password):
            return pwd_context.hash(password)

        def create_access_token(data: dict, expires_delta: timedelta = None):
            to_encode = data.copy()
            if expires_delta:
                expire = datetime.utcnow() + expires_delta
            else:
                expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
            to_encode.update({"exp": expire})
            encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
            return encoded_jwt
        EOF
        
        # app/services/binance_service.py ìƒì„±
        mkdir -p app/services
        cat > app/services/binance_service.py << 'EOF'
        from binance.client import Client
        from app.core.config import settings
        import asyncio
        from binance import AsyncClient, BinanceSocketManager

        async_client = AsyncClient(settings.BINANCE_API_KEY, settings.BINANCE_API_SECRET)

        async def get_current_price(symbol: str) -> float:
            ticker = await async_client.get_symbol_ticker(symbol=symbol)
            return float(ticker['price'])

        async def monitor_limit_order(order_id: int, symbol: str, side: str, price: float, quantity: float, callback):
            async with BinanceSocketManager(async_client) as bsm:
                ts = bsm.trade_socket(symbol)
                async with ts as tscm:
                    while True:
                        res = await tscm.recv()
                        current_price = float(res['p'])
                        if (side == 'buy' and current_price <= price) or (side == 'sell' and current_price >= price):
                            await callback(order_id, quantity, current_price)
                            break

        def execute_market_order(symbol: str, side: str, quantity: float):
            price = client.get_symbol_ticker(symbol=symbol)['price']
            return float(price)
        EOF
        
        # app/services/order_service.py ìƒì„±
        cat > app/services/order_service.py << 'EOF'
        from sqlmodel import Session, select
        from app.models.database import Order, Position, TradingAccount
        from app.services.binance_service import get_current_price, monitor_limit_order, execute_market_order
        from decimal import Decimal
        import asyncio

        async def create_order(session: Session, user_id: int, order_data):
            order = Order(user_id=user_id, **order_data.dict())
            session.add(order)
            session.commit()
            session.refresh(order)
            
            if order.order_type == 'market':
                price = execute_market_order(order.symbol, order.side, order.quantity)
                update_order_filled(session, order.id, order.quantity, Decimal(str(price)))
                update_position(session, user_id, order.symbol, order.side, order.quantity, Decimal(str(price)))
            elif order.order_type == 'limit':
                async def callback(order_id, quantity, price):
                    update_order_filled(session, order_id, Decimal(str(quantity)), Decimal(str(price)))
                    update_position(session, user_id, order.symbol, order.side, Decimal(str(quantity)), Decimal(str(price)))
                asyncio.create_task(monitor_limit_order(order.id, order.symbol, order.side, float(order.price), float(order.quantity), callback))
            
            return order

        def update_order_filled(session: Session, order_id: int, filled_qty: Decimal, price: Decimal):
            order = session.exec(select(Order).where(Order.id == order_id)).first()
            order.filled_quantity += filled_qty
            order.price = price if order.price is None else order.price
            order.order_status = 'filled' if order.filled_quantity == order.quantity else 'partially_filled'
            session.add(order)
            session.commit()

        def update_position(session: Session, user_id: int, symbol: str, side: str, quantity: Decimal, price: Decimal):
            account = session.exec(select(TradingAccount).where(TradingAccount.user_id == user_id)).first()
            position = session.exec(select(Position).where(Position.account_id == account.id, Position.symbol == symbol)).first()
            
            if not position:
                position = Position(account_id=account.id, symbol=symbol, quantity=0, average_price=0, current_value=0)
                session.add(position)
            
            if side == 'buy':
                new_qty = position.quantity + quantity
                new_avg_price = (position.average_price * position.quantity + price * quantity) / new_qty if new_qty > 0 else 0
                position.quantity = new_qty
                position.average_price = new_avg_price
                account.balance -= price * quantity
            elif side == 'sell':
                if position.quantity < quantity:
                    raise ValueError("Insufficient quantity to sell")
                position.quantity -= quantity
                profit = (price - position.average_price) * quantity
                account.total_profit += profit
                account.balance += price * quantity
            
            current_price = Decimal(str(asyncio.run(get_current_price(symbol))))
            position.current_value = position.quantity * current_price
            position.unrealized_profit = position.quantity * (current_price - position.average_price)
            session.add(position)
            session.add(account)
            session.commit()

        def get_account_summary(session: Session, user_id: int) -> dict:
            account = session.exec(select(TradingAccount).where(TradingAccount.user_id == user_id)).first()
            positions = session.exec(select(Position).where(Position.account_id == account.id)).all()
            total_value = account.balance + sum(p.current_value for p in positions)
            initial_balance = Decimal(str(settings.INITIAL_BALANCE))
            profit_rate = ((total_value - initial_balance) / initial_balance * 100) if initial_balance > 0 else 0
            return {
                "balance": account.balance,
                "total_profit": account.total_profit,
                "positions": positions,
                "profit_rate": profit_rate
            }
        EOF
        
        # app/routers/auth.py ìƒì„±
        mkdir -p app/routers
        cat > app/routers/auth.py << 'EOF'
        from fastapi import APIRouter, Depends, HTTPException, status
        from sqlmodel import Session, select
        from app.models.database import User, TradingAccount
        from app.schemas.user import UserCreate, UserLogin, UserOut
        from app.utils.security import get_password_hash, verify_password, create_access_token
        from app.core.database import get_session

        router = APIRouter(prefix="/auth", tags=["auth"])

        @router.post("/register", response_model=UserOut)
        def register(user: UserCreate, session: Session = Depends(get_session)):
            existing_user = session.exec(select(User).where(User.username == user.username)).first()
            if existing_user:
                raise HTTPException(status_code=400, detail="Username already registered")
            hashed_password = get_password_hash(user.password)
            db_user = User(username=user.username, hashed_password=hashed_password)
            session.add(db_user)
            session.commit()
            session.refresh(db_user)
            account = TradingAccount(user_id=db_user.id)
            session.add(account)
            session.commit()
            return db_user

        @router.post("/login")
        def login(user: UserLogin, session: Session = Depends(get_session)):
            db_user = session.exec(select(User).where(User.username == user.username)).first()
            if not db_user or not verify_password(user.password, db_user.hashed_password):
                raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
            access_token = create_access_token({"sub": db_user.username})
            return {"access_token": access_token, "token_type": "bearer"}
        EOF
        
        # app/routers/orders.py ìƒì„±
        cat > app/routers/orders.py << 'EOF'
        from fastapi import APIRouter, Depends, HTTPException
        from sqlmodel import Session
        from app.schemas.order import OrderCreate, OrderOut
        from app.services.order_service import create_order
        from app.core.database import get_session
        from fastapi.security import OAuth2PasswordBearer
        from jose import jwt
        from app.core.config import settings
        from app.models.database import User

        router = APIRouter(prefix="/orders", tags=["orders"])
        oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

        async def get_current_user(token: str = Depends(oauth2_scheme), session: Session = Depends(get_session)):
            try:
                payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
                username: str = payload.get("sub")
                if username is None:
                    raise HTTPException(status_code=401, detail="Invalid authentication credentials")
            except JWTError:
                raise HTTPException(status_code=401, detail="Invalid authentication credentials")
            user = session.exec(select(User).where(User.username == username)).first()
            if user is None:
                raise HTTPException(status_code=401, detail="User not found")
            return user

        @router.post("/", response_model=OrderOut)
        async def place_order(order: OrderCreate, current_user = Depends(get_current_user), session: Session = Depends(get_session)):
            return await create_order(session, current_user.id, order)
        EOF
        
        # app/routers/account.py ìƒì„±
        cat > app/routers/account.py << 'EOF'
        from fastapi import APIRouter, Depends
        from app.schemas.account import AccountOut
        from app.services.order_service import get_account_summary
        from app.core.database import get_session
        from app.routers.orders import get_current_user

        router = APIRouter(prefix="/account", tags=["account"])

        @router.get("/", response_model=AccountOut)
        def get_account(current_user = Depends(get_current_user), session: Session = Depends(get_session)):
            summary = get_account_summary(session, current_user.id)
            return AccountOut(**summary)
        EOF
        
        # app/core/database.py ìƒì„±
        cat > app/core/database.py << 'EOF'
        from sqlmodel import create_engine, Session
        from app.core.config import settings
        from contextlib import contextmanager

        engine = create_engine(settings.DATABASE_URL)

        @contextmanager
        def get_session():
            with Session(engine) as session:
                yield session
        EOF
        
        # app/main.py ìƒì„±
        mkdir -p app
        cat > app/main.py << 'EOF'
        from fastapi import FastAPI
        from fastapi.middleware.cors import CORSMiddleware
        from app.core.config import settings
        from app.models.database import create_db_and_tables
        from app.routers import auth, orders, account

        app = FastAPI(
            title=settings.PROJECT_NAME,
            openapi_url=f"{settings.API_V1_STR}/openapi.json"
        )

        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

        app.include_router(auth.router, prefix=settings.API_V1_STR)
        app.include_router(orders.router, prefix=settings.API_V1_STR)
        app.include_router(account.router, prefix=settings.API_V1_STR)

        @app.on_event("startup")
        def startup_event():
            create_db_and_tables()

        @app.get("/")
        async def root():
            return {"message": "BeenCoin API ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤!"}

        @app.get("/health")
        async def health_check():
            return {"status": "healthy"}

        if __name__ == "__main__":
            import uvicorn
            uvicorn.run(app, host="0.0.0.0", port=8000)
        EOF
        
        # __init__.py íŒŒì¼ë“¤ ìƒì„±
        touch app/__init__.py
        touch app/core/__init__.py
        touch app/api/__init__.py
        touch app/api/v1/__init__.py
        touch app/api/v1/endpoints/__init__.py
        touch app/models/__init__.py
        touch app/services/__init__.py
        touch app/utils/__init__.py
        touch app/schemas/__init__.py
        touch app/routers/__init__.py
        
        # README.md ìƒì„±
        cat > README.md << 'EOF'
        # BeenCoin - ì‹¤ì‹œê°„ ì•”í˜¸í™”í ëª¨ì˜íˆ¬ìž í”Œëž«í¼

        ## ðŸš€ ì£¼ìš” ê¸°ëŠ¥
        - íšŒì›ê°€ìž…/ë¡œê·¸ì¸ (ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ ê¸°ë°˜)
        - ì‹¤ì‹œê°„ ì•”í˜¸í™”í ì‹œì„¸ ì¡°íšŒ (Binance API)
        - ëª¨ì˜íˆ¬ìž ì£¼ë¬¸ ì‹œìŠ¤í…œ (ì‹œìž¥ê°€/ì§€ì •ê°€, ë§¤ìˆ˜/ë§¤ë„)
        - ì‹¤ì œ ì‹œìž¥ ë°ì´í„° ê¸°ë°˜ ì£¼ë¬¸ ì‹¤í–‰ (ì§€ì •ê°€ ì£¼ë¬¸ì€ WebSocket ëª¨ë‹ˆí„°ë§)
        - í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ë° ìˆ˜ìµë¥  í‘œì‹œ
        - WebSocket ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°

        ## âš¡ ë¹ ë¥¸ ì‹œìž‘
        1. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •: .env íŒŒì¼ ìƒì„± (.env.example ì°¸ì¡°)
        2. ```bash
           pip install -r requirements.txt
           uvicorn app.main:app --reload
           ```

        ## ðŸ“Š API ë¬¸ì„œ
        - Swagger UI: http://localhost:8000/docs
        - ReDoc: http://localhost:8000/redoc

        ## ðŸ—ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡°
        ```
        BeenCoin/
        â”œâ”€â”€ app/
        â”‚   â”œâ”€â”€ main.py
        â”‚   â”œâ”€â”€ core/          # ì„¤ì • ê´€ë¦¬
        â”‚   â”œâ”€â”€ models/        # ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸
        â”‚   â”œâ”€â”€ schemas/       # Pydantic ìŠ¤í‚¤ë§ˆ
        â”‚   â”œâ”€â”€ routers/       # API ë¼ìš°í„°
        â”‚   â”œâ”€â”€ services/      # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (Binance, Order ì²˜ë¦¬)
        â”‚   â”œâ”€â”€ utils/         # ìœ í‹¸ë¦¬í‹° (ë³´ì•ˆ ë“±)
        â”‚   â”œâ”€â”€ api/v1/        # API ì—”ë“œí¬ì¸íŠ¸ (ë¯¸ì‚¬ìš© ì‹œ ì‚­ì œ ê°€ëŠ¥)
        â”‚   â””â”€â”€ __init__.py
        â”œâ”€â”€ tests/
        â”œâ”€â”€ .env.example
        â””â”€â”€ requirements.txt
        ```

        ## ðŸ“ ì¶”ê°€ ì„¤ëª…
        - íšŒì›ê°€ìž…: POST /api/v1/auth/register {username, password}
        - ë¡œê·¸ì¸: POST /api/v1/auth/login {username, password} â†’ JWT í† í° ë°˜í™˜
        - ì£¼ë¬¸: POST /api/v1/orders {symbol, side, order_type, quantity, price?} (Authorization: Bearer <token>)
        - ê³„ì¢Œ ì¡°íšŒ: GET /api/v1/account (Authorization: Bearer <token>) â†’ balance, total_profit, positions, profit_rate
        - ì£¼ë¬¸ ì²˜ë¦¬: ì‹œìž¥ê°€ëŠ” ì¦‰ì‹œ ì‹¤í–‰, ì§€ì •ê°€ëŠ” WebSocketìœ¼ë¡œ ê°€ê²© ëª¨ë‹ˆí„°ë§ í›„ ì‹¤í–‰.
        - ìˆ˜ìµë¥ : (í˜„ìž¬ ì´ ê°€ì¹˜ - ì´ˆê¸° ìž”ê³ ) / ì´ˆê¸° ìž”ê³  * 100
        EOF
        
        # .gitignore ìƒì„±
        cat > .gitignore << 'EOF'
        __pycache__/
        *.pyc
        *.pyo
        *.pyd
        .Python
        env/
        venv/
        .venv/
        *.sqlite3
        *.db
        .DS_Store
        .coverage
        htmlcov/
        .pytest_cache/
        *.log
        instance/
        .webassets-cache
        .scrapy
        docs/_build/
        target/
        .ipynb_checkpoints
        .python-version
        .env
        .venv
        npm-debug.log*
        yarn-debug.log*
        yarn-error.log*
        EOF

    - name: Commit and push project files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit --allow-empty -m "ðŸš€ BeenCoin í”„ë¡œì íŠ¸ í™•ìž¥: ëª¨ë“  íŒŒì¼ ìƒì„± ë° ëª¨ì˜íˆ¬ìž ê¸°ëŠ¥ ì¶”ê°€"
        git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/gswx31/BeenCoin.git || echo "Push failed, creating PR instead"
    
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "ðŸš€ BeenCoin í”„ë¡œì íŠ¸ í™•ìž¥: ëª¨ë“  íŒŒì¼ ìƒì„± ë° ëª¨ì˜íˆ¬ìž ê¸°ëŠ¥ ì¶”ê°€"
        title: "BeenCoin í”„ë¡œì íŠ¸ í™•ìž¥"
        body: "ëª¨ì˜íˆ¬ìž ê¸°ëŠ¥ ê°•í™”: íšŒì›ê°€ìž…, ì‹¤ì œ ì‹œìž¥ ê¸°ë°˜ ì£¼ë¬¸ ì‹¤í–‰, ë§¤ìˆ˜/ë§¤ë„ ì²˜ë¦¬, ìˆ˜ìµë¥  ê³„ì‚°"
        branch: "auto-expand-branch"
```
