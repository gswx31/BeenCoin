name: Setup BeenCoin Project

on:
  workflow_dispatch:  # ìˆ˜ë™ ì‹¤í–‰ ê°€ëŠ¥
  push:
    branches: [ main ]

jobs:
  setup-project:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Create project structure
      run: |
        # í´ë” êµ¬ì¡° ìƒì„± (ì¶”ê°€: client for frontend, with React setup)
        mkdir -p app/{core,api/v1/endpoints,models,services,utils,schemas,routers,background_tasks} tests/{unit,integration} client/{src/components,public}
        mkdir -p .github/workflows
        
        # requirements.txt ìƒì„± (ì¶”ê°€: frontend buildë¥¼ ìœ„í•œ node, but since it's Actions, we'll generate static files)
        cat > requirements.txt << 'EOF'
        fastapi==0.104.1
        uvicorn==0.24.0
        sqlalchemy==2.0.23
        sqlmodel==0.0.11
        pydantic==2.5.0
        python-jose==3.3.0
        passlib==1.7.4
        bcrypt==4.0.1
        python-multipart==0.0.6
        httpx==0.25.2
        websockets==12.0
        redis==5.0.1
        aioredis==2.0.1
        pytest==7.4.3
        pytest-asyncio==0.21.1
        aiohttp==3.9.1
        celery==5.3.4
        python-binance==1.0.19
        python-dotenv==1.0.0
        flower==2.0.1
        faker==19.13.0
        EOF
        
        # .env.example ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > .env.example << 'EOF'
        DATABASE_URL=sqlite+aiosqlite:///./beencoin.db
        SECRET_KEY=your-secret-key-change-in-production
        BINANCE_API_KEY=your-binance-api-key
        BINANCE_API_SECRET=your-binance-api-secret
        REDIS_URL=redis://localhost:6379/0
        CELERY_BROKER_URL=redis://localhost:6379/0
        CELERY_RESULT_BACKEND=redis://localhost:6379/0
        EOF
        
        # app/core/config.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/core
        cat > app/core/config.py << 'EOF'
        from pydantic_settings import BaseSettings
        from typing import Optional
        from dotenv import load_dotenv
        import os

        load_dotenv()

        class Settings(BaseSettings):
            API_V1_STR: str = "/api/v1"
            PROJECT_NAME: str = "BeenCoin API"
            DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./beencoin.db")
            SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
            ALGORITHM: str = "HS256"
            ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
            BINANCE_API_URL: str = "https://api.binance.com/api/v3"
            BINANCE_API_KEY: Optional[str] = os.getenv("BINANCE_API_KEY")
            BINANCE_API_SECRET: Optional[str] = os.getenv("BINANCE_API_SECRET")
            REDIS_URL: str = os.getenv("REDIS_URL", "redis://localhost:6379/0")
            CELERY_BROKER_URL: str = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
            CELERY_RESULT_BACKEND: str = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")
            INITIAL_BALANCE: float = 1000000.0
            SUPPORTED_SYMBOLS: list = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]  # ì§€ì› ì½”ì¸ ì œí•œ

            class Config:
                case_sensitive = True

        settings = Settings()
        EOF
        
        # app/models/database.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/models
        cat > app/models/database.py << 'EOF'
        from sqlmodel import SQLModel, Field, Relationship, create_engine
        from typing import Optional, List
        from datetime import datetime
        from decimal import Decimal
        from app.core.config import settings

        class User(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            username: str = Field(unique=True, index=True)
            hashed_password: str
            is_active: bool = True
            created_at: datetime = Field(default_factory=datetime.utcnow)
            accounts: List["TradingAccount"] = Relationship(back_populates="user")
            orders: List["Order"] = Relationship(back_populates="user")
            transactions: List["TransactionHistory"] = Relationship(back_populates="user")

        class TradingAccount(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            user_id: int = Field(foreign_key="user.id")
            balance: Decimal = Field(default=Decimal('1000000.00000000'), max_digits=20, decimal_places=8)
            total_profit: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            user: User = Relationship(back_populates="accounts")
            positions: List["Position"] = Relationship(back_populates="account")

        class Order(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            user_id: int = Field(foreign_key="user.id")
            symbol: str
            side: str  # 'BUY' or 'SELL'
            order_type: str  # 'MARKET' or 'LIMIT'
            order_status: str = "PENDING"
            price: Optional[Decimal] = Field(default=None, max_digits=20, decimal_places=8)
            quantity: Decimal = Field(max_digits=20, decimal_places=8)
            filled_quantity: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            created_at: datetime = Field(default_factory=datetime.utcnow)
            updated_at: datetime = Field(default_factory=datetime.utcnow)
            user: User = Relationship(back_populates="orders")

        class Position(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            account_id: int = Field(foreign_key="tradingaccount.id")
            symbol: str
            quantity: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            average_price: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            current_value: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            unrealized_profit: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            account: TradingAccount = Relationship(back_populates="positions")

        class TransactionHistory(SQLModel, table=True):
            id: Optional[int] = Field(default=None, primary_key=True)
            user_id: int = Field(foreign_key="user.id")
            order_id: Optional[int] = Field(default=None, foreign_key="order.id")
            symbol: str
            side: str
            quantity: Decimal = Field(max_digits=20, decimal_places=8)
            price: Decimal = Field(max_digits=20, decimal_places=8)
            fee: Decimal = Field(default=Decimal('0.00000000'), max_digits=20, decimal_places=8)
            timestamp: datetime = Field(default_factory=datetime.utcnow)
            user: User = Relationship(back_populates="transactions")

        def create_db_and_tables():
            engine = create_engine(settings.DATABASE_URL, echo=True)  # ë””ë²„ê¹…ìš© echo
            SQLModel.metadata.create_all(engine)
        EOF
        
        # app/schemas/user.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/schemas
        cat > app/schemas/user.py << 'EOF'
        from pydantic import BaseModel, validator
        from typing import Optional

        class UserBase(BaseModel):
            username: str

        class UserCreate(UserBase):
            password: str

            @validator('password')
            def password_strength(cls, v):
                if len(v) < 8:
                    raise ValueError('Password must be at least 8 characters')
                return v

        class UserLogin(UserBase):
            password: str

        class UserOut(UserBase):
            id: int
            created_at: str
        EOF
        
        # app/schemas/order.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/schemas/order.py << 'EOF'
        from pydantic import BaseModel, validator
        from decimal import Decimal
        from typing import Optional
        from app.core.config import settings

        class OrderCreate(BaseModel):
            symbol: str
            side: str  # 'BUY' or 'SELL'
            order_type: str  # 'MARKET' or 'LIMIT'
            quantity: Decimal
            price: Optional[Decimal] = None

            @validator('symbol')
            def validate_symbol(cls, v):
                if v.upper() not in settings.SUPPORTED_SYMBOLS:
                    raise ValueError(f'Unsupported symbol: {v}. Supported: {settings.SUPPORTED_SYMBOLS}')
                return v.upper()

            @validator('side')
            def validate_side(cls, v):
                if v.upper() not in ['BUY', 'SELL']:
                    raise ValueError('Side must be BUY or SELL')
                return v.upper()

            @validator('order_type')
            def validate_order_type(cls, v):
                if v.upper() not in ['MARKET', 'LIMIT']:
                    raise ValueError('Order type must be MARKET or LIMIT')
                return v.upper()

            @validator('price')
            def validate_price(cls, v, values):
                if values.get('order_type') == 'LIMIT' and v is None:
                    raise ValueError('Price is required for LIMIT orders')
                if values.get('order_type') == 'MARKET' and v is not None:
                    raise ValueError('Price should not be provided for MARKET orders')
                return v

        class OrderOut(OrderCreate):
            id: int
            order_status: str
            filled_quantity: Decimal
            created_at: str
            updated_at: str
        EOF
        
        # app/schemas/account.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/schemas/account.py << 'EOF'
        from pydantic import BaseModel
        from decimal import Decimal
        from typing import List

        class PositionOut(BaseModel):
            symbol: str
            quantity: Decimal
            average_price: Decimal
            current_value: Decimal
            unrealized_profit: Decimal

        class AccountOut(BaseModel):
            balance: Decimal
            total_profit: Decimal
            positions: List[PositionOut]
            profit_rate: Decimal
            total_value: Decimal
        EOF
        
        # app/schemas/transaction.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/schemas/transaction.py << 'EOF'
        from pydantic import BaseModel
        from decimal import Decimal

        class TransactionOut(BaseModel):
            id: int
            symbol: str
            side: str
            quantity: Decimal
            price: Decimal
            fee: Decimal
            timestamp: str
        EOF
        
        # app/utils/security.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/utils
        cat > app/utils/security.py << 'EOF'
        from passlib.context import CryptContext
        from jose import JWTError, jwt
        from datetime import datetime, timedelta
        from fastapi import HTTPException, status
        from app.core.config import settings

        pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

        def verify_password(plain_password: str, hashed_password: str) -> bool:
            return pwd_context.verify(plain_password, hashed_password)

        def get_password_hash(password: str) -> str:
            return pwd_context.hash(password)

        def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
            to_encode = data.copy()
            if expires_delta:
                expire = datetime.utcnow() + expires_delta
            else:
                expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
            to_encode.update({"exp": expire})
            encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
            return encoded_jwt

        def decode_access_token(token: str) -> dict:
            try:
                return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
            except JWTError:
                raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
        EOF
        
        # app/services/binance_service.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/services
        cat > app/services/binance_service.py << 'EOF'
        from binance.client import AsyncClient, BinanceSocketManager
        from app.core.config import settings
        from fastapi import HTTPException
        import asyncio
        from typing import Callable

        async_client = AsyncClient(settings.BINANCE_API_KEY, settings.BINANCE_API_SECRET)

        async def get_current_price(symbol: str) -> Decimal:
            try:
                ticker = await async_client.get_symbol_ticker(symbol=symbol)
                return Decimal(ticker['price'])
            except Exception as e:
                raise HTTPException(status_code=503, detail=f"Binance API error: {str(e)}")

        async def monitor_limit_order(order_id: int, symbol: str, side: str, price: Decimal, quantity: Decimal, callback: Callable):
            try:
                async with BinanceSocketManager(async_client) as bsm:
                    ts = bsm.trade_socket(symbol)
                    async with ts as tscm:
                        while True:
                            res = await tscm.recv()
                            if 'p' not in res:
                                continue
                            current_price = Decimal(res['p'])
                            if (side == 'BUY' and current_price <= price) or (side == 'SELL' and current_price >= price):
                                await callback(order_id, quantity, current_price)
                                break
            except Exception as e:
                print(f"WebSocket error for order {order_id}: {str(e)}")  # ë¡œê¹…

        async def execute_market_order(symbol: str, side: str, quantity: Decimal) -> Decimal:
            price = await get_current_price(symbol)
            # ì‹¤ì œ Binance ì£¼ë¬¸ ëŒ€ì‹  ëª¨ì˜ (ëª¨ì˜ íˆ¬ìì´ë¯€ë¡œ)
            return price
        EOF
        
        # app/services/order_service.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/services/order_service.py << 'EOF'
        from sqlmodel import Session, select
        from app.models.database import Order, Position, TradingAccount, TransactionHistory
        from app.services.binance_service import get_current_price, monitor_limit_order, execute_market_order
        from decimal import Decimal
        import asyncio
        from app.schemas.order import OrderCreate
        from fastapi import HTTPException

        FEE_RATE = Decimal('0.001')  # 0.1% ìˆ˜ìˆ˜ë£Œ

        async def create_order(session: Session, user_id: int, order_data: OrderCreate) -> Order:
            if order_data.symbol not in settings.SUPPORTED_SYMBOLS:
                raise HTTPException(status_code=400, detail="Unsupported symbol")
            
            order = Order(user_id=user_id, **order_data.dict())
            session.add(order)
            session.commit()
            session.refresh(order)
            
            if order.order_type == 'MARKET':
                price = await execute_market_order(order.symbol, order.side, order.quantity)
                filled_qty = order.quantity
                fee = price * filled_qty * FEE_RATE
                update_order_filled(session, order.id, filled_qty, price)
                update_position(session, user_id, order.symbol, order.side, filled_qty, price, fee)
                record_transaction(session, user_id, order.id, order.symbol, order.side, filled_qty, price, fee)
            elif order.order_type == 'LIMIT':
                async def callback(order_id: int, quantity: Decimal, price: Decimal):
                    with session.begin():
                        filled_qty = quantity
                        fee = price * filled_qty * FEE_RATE
                        update_order_filled(session, order_id, filled_qty, price)
                        update_position(session, user_id, order.symbol, order.side, filled_qty, price, fee)
                        record_transaction(session, user_id, order_id, order.symbol, order.side, filled_qty, price, fee)
                asyncio.create_task(monitor_limit_order(order.id, order.symbol, order.side, order.price, order.quantity, callback))
            
            return order

        def update_order_filled(session: Session, order_id: int, filled_qty: Decimal, price: Decimal):
            order = session.exec(select(Order).where(Order.id == order_id)).first()
            if not order:
                raise HTTPException(status_code=404, detail="Order not found")
            order.filled_quantity += filled_qty
            order.price = price if order.price is None else order.price
            order.order_status = 'FILLED' if order.filled_quantity >= order.quantity else 'PARTIALLY_FILLED'
            order.updated_at = datetime.utcnow()
            session.add(order)
            session.commit()

        def update_position(session: Session, user_id: int, symbol: str, side: str, quantity: Decimal, price: Decimal, fee: Decimal):
            account = session.exec(select(TradingAccount).where(TradingAccount.user_id == user_id)).first()
            if not account:
                raise HTTPException(status_code=404, detail="Account not found")
            position = session.exec(select(Position).where(Position.account_id == account.id, Position.symbol == symbol)).first()
            
            if not position:
                position = Position(account_id=account.id, symbol=symbol, quantity=Decimal('0'), average_price=Decimal('0'), current_value=Decimal('0'), unrealized_profit=Decimal('0'))
                session.add(position)
                session.commit()
                session.refresh(position)
            
            cost = price * quantity
            net_cost = cost + fee if side == 'BUY' else cost - fee
            
            if side == 'BUY':
                if account.balance < net_cost:
                    raise HTTPException(status_code=400, detail="Insufficient balance")
                new_qty = position.quantity + quantity
                new_avg_price = ((position.average_price * position.quantity) + cost) / new_qty if new_qty > 0 else Decimal('0')
                position.quantity = new_qty
                position.average_price = new_avg_price
                account.balance -= net_cost
            elif side == 'SELL':
                if position.quantity < quantity:
                    raise HTTPException(status_code=400, detail="Insufficient quantity to sell")
                position.quantity -= quantity
                profit = (price - position.average_price) * quantity - fee
                account.total_profit += profit
                account.balance += net_cost
            
            current_price = asyncio.run(get_current_price(symbol))
            position.current_value = position.quantity * current_price
            position.unrealized_profit = position.quantity * (current_price - position.average_price)
            session.add(position)
            session.add(account)
            session.commit()

        def record_transaction(session: Session, user_id: int, order_id: Optional[int], symbol: str, side: str, quantity: Decimal, price: Decimal, fee: Decimal):
            transaction = TransactionHistory(user_id=user_id, order_id=order_id, symbol=symbol, side=side, quantity=quantity, price=price, fee=fee)
            session.add(transaction)
            session.commit()

        def get_user_orders(session: Session, user_id: int) -> List[Order]:
            return session.exec(select(Order).where(Order.user_id == user_id).order_by(Order.created_at.desc())).all()

        def get_account_summary(session: Session, user_id: int) -> dict:
            account = session.exec(select(TradingAccount).where(TradingAccount.user_id == user_id)).first()
            if not account:
                raise HTTPException(status_code=404, detail="Account not found")
            positions = session.exec(select(Position).where(Position.account_id == account.id)).all()
            total_value = account.balance + sum(p.current_value for p in positions)
            initial_balance = Decimal(str(settings.INITIAL_BALANCE))
            profit_rate = ((total_value - initial_balance) / initial_balance * 100) if initial_balance > 0 else Decimal('0')
            return {
                "balance": account.balance,
                "total_profit": account.total_profit,
                "positions": [p.dict() for p in positions],
                "profit_rate": profit_rate,
                "total_value": total_value
            }

        def get_transaction_history(session: Session, user_id: int) -> List[TransactionHistory]:
            return session.exec(select(TransactionHistory).where(TransactionHistory.user_id == user_id).order_by(TransactionHistory.timestamp.desc())).all()
        EOF
        
        # app/routers/auth.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p app/routers
        cat > app/routers/auth.py << 'EOF'
        from fastapi import APIRouter, Depends, HTTPException, status
        from sqlmodel import Session, select
        from app.models.database import User, TradingAccount
        from app.schemas.user import UserCreate, UserLogin, UserOut
        from app.utils.security import get_password_hash, verify_password, create_access_token
        from app.core.database import get_session

        router = APIRouter(prefix="/auth", tags=["auth"])

        @router.post("/register", response_model=UserOut)
        def register(user: UserCreate, session: Session = Depends(get_session)):
            existing_user = session.exec(select(User).where(User.username == user.username)).first()
            if existing_user:
                raise HTTPException(status_code=400, detail="Username already registered")
            hashed_password = get_password_hash(user.password)
            db_user = User(username=user.username, hashed_password=hashed_password)
            session.add(db_user)
            session.commit()
            session.refresh(db_user)
            # ê¸°ë³¸ ê³„ì¢Œ ìƒì„±
            existing_account = session.exec(select(TradingAccount).where(TradingAccount.user_id == db_user.id)).first()
            if not existing_account:
                account = TradingAccount(user_id=db_user.id, balance=Decimal(str(settings.INITIAL_BALANCE)))
                session.add(account)
                session.commit()
            return UserOut(id=db_user.id, username=db_user.username, created_at=str(db_user.created_at))

        @router.post("/login")
        def login(user: UserLogin, session: Session = Depends(get_session)):
            db_user = session.exec(select(User).where(User.username == user.username)).first()
            if not db_user or not verify_password(user.password, db_user.hashed_password):
                raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
            if not db_user.is_active:
                raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User is inactive")
            access_token = create_access_token({"sub": db_user.username})
            return {"access_token": access_token, "token_type": "bearer"}
        EOF
        
        # app/routers/orders.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/routers/orders.py << 'EOF'
        from fastapi import APIRouter, Depends
        from sqlmodel import Session
        from app.schemas.order import OrderCreate, OrderOut
        from app.services.order_service import create_order, get_user_orders
        from app.core.database import get_session
        from fastapi.security import OAuth2PasswordBearer
        from typing import List
        from app.utils.security import decode_access_token
        from app.models.database import User
        from app.core.config import settings
        from fastapi import HTTPException

        router = APIRouter(prefix="/orders", tags=["orders"])
        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/login")

        def get_current_user(token: str = Depends(oauth2_scheme), session: Session = Depends(get_session)) -> User:
            payload = decode_access_token(token)
            username: str = payload.get("sub")
            if username is None:
                raise HTTPException(status_code=401, detail="Invalid authentication credentials")
            user = session.exec(select(User).where(User.username == username)).first()
            if user is None:
                raise HTTPException(status_code=401, detail="User not found")
            return user

        @router.post("/", response_model=OrderOut)
        async def place_order(order: OrderCreate, current_user: User = Depends(get_current_user), session: Session = Depends(get_session)):
            return await create_order(session, current_user.id, order)

        @router.get("/", response_model=List[OrderOut])
        def get_orders(current_user: User = Depends(get_current_user), session: Session = Depends(get_session)):
            orders = get_user_orders(session, current_user.id)
            return [OrderOut(**o.dict(), created_at=str(o.created_at), updated_at=str(o.updated_at)) for o in orders]
        EOF
        
        # app/routers/account.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/routers/account.py << 'EOF'
        from fastapi import APIRouter, Depends
        from app.schemas.account import AccountOut
        from app.schemas.transaction import TransactionOut
        from app.services.order_service import get_account_summary, get_transaction_history
        from app.core.database import get_session
        from app.routers.orders import get_current_user
        from typing import List

        router = APIRouter(prefix="/account", tags=["account"])

        @router.get("/", response_model=AccountOut)
        def get_account(current_user = Depends(get_current_user), session: Session = Depends(get_session)):
            summary = get_account_summary(session, current_user.id)
            return AccountOut(**summary)

        @router.get("/transactions", response_model=List[TransactionOut])
        def get_transactions(current_user = Depends(get_current_user), session: Session = Depends(get_session)):
            transactions = get_transaction_history(session, current_user.id)
            return [TransactionOut(**t.dict(), timestamp=str(t.timestamp)) for t in transactions]
        EOF
        
        # app/routers/websocket.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/routers/websocket.py << 'EOF'
        from fastapi import APIRouter, WebSocket, Depends
        from app.services.binance_service import async_client
        from binance import BinanceSocketManager
        from app.routers.orders import get_current_user
        from app.core.database import get_session
        from sqlmodel import Session

        router = APIRouter(prefix="/ws", tags=["websocket"])

        @router.websocket("/prices/{symbol}")
        async def websocket_prices(websocket: WebSocket, symbol: str, current_user = Depends(get_current_user), session: Session = Depends(get_session)):
            await websocket.accept()
            async with BinanceSocketManager(async_client) as bsm:
                ts = bsm.trade_socket(symbol)
                async with ts as tscm:
                    while True:
                        try:
                            res = await tscm.recv()
                            if 'p' in res:
                                await websocket.send_json({"symbol": symbol, "price": res['p']})
                        except Exception as e:
                            await websocket.close()
                            break
        EOF
        
        # app/background_tasks/celery_app.py ìƒì„± (ê¸°ì¡´ ë™ì¼, but optional in README)
        mkdir -p app/background_tasks
        cat > app/background_tasks/celery_app.py << 'EOF'
        from celery import Celery
        from app.core.config import settings

        celery_app = Celery(
            "beencoin",
            broker=settings.CELERY_BROKER_URL,
            backend=settings.CELERY_RESULT_BACKEND,
            include=['app.background_tasks.tasks']
        )

        celery_app.conf.update(
            task_serializer='json',
            result_serializer='json',
            accept_content=['json'],
            timezone='UTC',
            enable_utc=True,
        )
        EOF
        
        # app/background_tasks/tasks.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/background_tasks/tasks.py << 'EOF'
        from app.background_tasks.celery_app import celery_app
        from app.services.order_service import update_position
        from app.core.database import engine
        from sqlmodel import Session, select
        from app.models.database import User, Position
        from app.services.binance_service import get_current_price
        import asyncio

        @celery_app.task
        def update_all_positions():
            with Session(engine) as session:
                users = session.exec(select(User)).all()
                for user in users:
                    positions = session.exec(select(Position).where(Position.account_id == user.accounts[0].id if user.accounts else None)).all()
                    for pos in positions:
                        if pos.quantity > 0:
                            current_price = asyncio.run(get_current_price(pos.symbol))
                            pos.current_value = pos.quantity * current_price
                            pos.unrealized_profit = pos.quantity * (current_price - pos.average_price)
                            session.add(pos)
                session.commit()
        EOF
        
        # app/core/database.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        cat > app/core/database.py << 'EOF'
        from sqlmodel import create_engine, Session
        from app.core.config import settings

        engine = create_engine(settings.DATABASE_URL, echo=True)

        def get_session():
            with Session(engine) as session:
                yield session
        EOF
        
        # app/main.py ìƒì„± (ì¶”ê°€: static files for frontend)
        mkdir -p app
        cat > app/main.py << 'EOF'
        from fastapi import FastAPI
        from fastapi.middleware.cors import CORSMiddleware
        from fastapi.staticfiles import StaticFiles
        from app.core.config import settings
        from app.models.database import create_db_and_tables
        from app.routers import auth, orders, account, websocket
        from app.background_tasks.celery_app import celery_app
        from app.background_tasks.tasks import update_all_positions

        app = FastAPI(
            title=settings.PROJECT_NAME,
            openapi_url=f"{settings.API_V1_STR}/openapi.json"
        )

        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

        app.include_router(auth.router, prefix=settings.API_V1_STR)
        app.include_router(orders.router, prefix=settings.API_V1_STR)
        app.include_router(account.router, prefix=settings.API_V1_STR)
        app.include_router(websocket.router, prefix=settings.API_V1_STR)

        # Mount frontend static files
        app.mount("/", StaticFiles(directory="client/build", html=True), name="static")

        @app.on_event("startup")
        async def startup_event():
            create_db_and_tables()
            # Celery beat ìŠ¤ì¼€ì¤„ (ë§¤ 5ë¶„ position ì—…ë°ì´íŠ¸) - optional
            celery_app.conf.beat_schedule = {
                'update-positions-every-5-minutes': {
                    'task': 'app.background_tasks.tasks.update_all_positions',
                    'schedule': 300.0,  # 5 minutes
                },
            }

        @app.get("/")
        async def root():
            return {"message": "BeenCoin API ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤!"}

        @app.get("/health")
        async def health_check():
            return {"status": "healthy"}

        if __name__ == "__main__":
            import uvicorn
            uvicorn.run(app, host="0.0.0.0", port=8000)
        EOF
        
        # tests/unit/test_order_service.py ìƒì„± (ê¸°ì¡´ ë™ì¼)
        mkdir -p tests/unit
        cat > tests/unit/test_order_service.py << 'EOF'
        import pytest
        from decimal import Decimal
        from app.services.order_service import update_position
        from app.models.database import TradingAccount, Position
        from sqlmodel import Session, create_engine
        from sqlalchemy.pool import StaticPool

        @pytest.fixture
        def session():
            engine = create_engine("sqlite://", connect_args={"check_same_thread": False}, poolclass=StaticPool)
            from app.models.database import SQLModel
            SQLModel.metadata.create_all(engine)
            with Session(engine) as session:
                yield session

        def test_update_position_buy(session: Session):
            account = TradingAccount(id=1, user_id=1, balance=Decimal('1000000'))
            session.add(account)
            session.commit()
            update_position(session, 1, "BTCUSDT", "BUY", Decimal('1'), Decimal('50000'), Decimal('50'))
            position = session.exec(Position.select().where(Position.symbol == "BTCUSDT")).first()
            assert position.quantity == Decimal('1')
            assert account.balance == Decimal('999950')  # 50000 - 50 fee? Wait, fee is added to cost

        # ì¶”ê°€ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±
        EOF
        
        # Frontend setup: Create a simple React app in client/
        cd client
        cat > package.json << 'EOF'
        {
          "name": "beencoin-frontend",
          "version": "0.1.0",
          "private": true,
          "dependencies": {
            "react": "^18.2.0",
            "react-dom": "^18.2.0",
            "react-scripts": "5.0.1",
            "chart.js": "^4.4.4",
            "react-chartjs-2": "^5.2.0",
            "axios": "^1.7.7",
            "react-router-dom": "^6.27.0",
            "react-toastify": "^10.0.5",
            "recharts": "^2.12.7"
          },
          "scripts": {
            "start": "react-scripts start",
            "build": "react-scripts build",
            "test": "react-scripts test",
            "eject": "react-scripts eject"
          },
          "eslintConfig": {
            "extends": [
              "react-app",
              "react-app/jest"
            ]
          },
          "browserslist": [
            ">0.2%",
            "not dead",
            "not op_mini all"
          ]
        }
        EOF
        
        cat > public/index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
              name="description"
              content="BeenCoin ëª¨ì˜íˆ¬ì í”Œë«í¼"
            />
            <title>BeenCoin</title>
          </head>
          <body>
            <noscript>You need to enable JavaScript to run this app.</noscript>
            <div id="root"></div>
          </body>
        </html>
        EOF
        
        mkdir -p src/components
        cat > src/App.js << 'EOF'
        import React from 'react';
        import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
        import Login from './components/Login';
        import Register from './components/Register';
        import Dashboard from './components/Dashboard';
        import Portfolio from './components/Portfolio';
        import OrderForm from './components/OrderForm';
        import { ToastContainer } from 'react-toastify';
        import 'react-toastify/dist/ReactToastify.css';

        function App() {
          return (
            <Router>
              <div className="App">
                <Routes>
                  <Route path="/login" element={<Login />} />
                  <Route path="/register" element={<Register />} />
                  <Route path="/dashboard" element={<Dashboard />} />
                  <Route path="/portfolio" element={<Portfolio />} />
                  <Route path="/order" element={<OrderForm />} />
                  <Route path="/" element={<Login />} />
                </Routes>
                <ToastContainer />
              </div>
            </Router>
          );
        }

        export default App;
        EOF
        
        cat > src/components/Login.js << 'EOF'
        import React, { useState } from 'react';
        import axios from 'axios';
        import { useNavigate } from 'react-router-dom';
        import { toast } from 'react-toastify';

        const Login = () => {
          const [username, setUsername] = useState('');
          const [password, setPassword] = useState('');
          const navigate = useNavigate();

          const handleSubmit = async (e) => {
            e.preventDefault();
            try {
              const response = await axios.post('/api/v1/auth/login', { username, password });
              localStorage.setItem('token', response.data.access_token);
              toast.success('ë¡œê·¸ì¸ ì„±ê³µ!');
              navigate('/dashboard');
            } catch (error) {
              toast.error('ë¡œê·¸ì¸ ì‹¤íŒ¨: ' + (error.response?.data?.detail || 'ì˜¤ë¥˜ ë°œìƒ'));
            }
          };

          return (
            <div style={{ maxWidth: '400px', margin: 'auto', padding: '20px' }}>
              <h2>ë¡œê·¸ì¸</h2>
              <form onSubmit={handleSubmit}>
                <input
                  type="text"
                  placeholder="ì•„ì´ë””"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  style={{ display: 'block', margin: '10px 0', width: '100%' }}
                />
                <input
                  type="password"
                  placeholder="ë¹„ë°€ë²ˆí˜¸"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  style={{ display: 'block', margin: '10px 0', width: '100%' }}
                />
                <button type="submit" style={{ width: '100%' }}>ë¡œê·¸ì¸</button>
              </form>
              <p>ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”? <a href="/register">íšŒì›ê°€ì…</a></p>
            </div>
          );
        };

        export default Login;
        EOF
        
        cat > src/components/Register.js << 'EOF'
        import React, { useState } from 'react';
        import axios from 'axios';
        import { useNavigate } from 'react-router-dom';
        import { toast } from 'react-toastify';

        const Register = () => {
          const [username, setUsername] = useState('');
          const [password, setPassword] = useState('');
          const navigate = useNavigate();

          const handleSubmit = async (e) => {
            e.preventDefault();
            try {
              await axios.post('/api/v1/auth/register', { username, password });
              toast.success('íšŒì›ê°€ì… ì„±ê³µ! ë¡œê·¸ì¸í•˜ì„¸ìš”.');
              navigate('/login');
            } catch (error) {
              toast.error('íšŒì›ê°€ì… ì‹¤íŒ¨: ' + (error.response?.data?.detail || 'ì˜¤ë¥˜ ë°œìƒ'));
            }
          };

          return (
            <div style={{ maxWidth: '400px', margin: 'auto', padding: '20px' }}>
              <h2>íšŒì›ê°€ì…</h2>
              <form onSubmit={handleSubmit}>
                <input
                  type="text"
                  placeholder="ì•„ì´ë””"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  style={{ display: 'block', margin: '10px 0', width: '100%' }}
                />
                <input
                  type="password"
                  placeholder="ë¹„ë°€ë²ˆí˜¸"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  style={{ display: 'block', margin: '10px 0', width: '100%' }}
                />
                <button type="submit" style={{ width: '100%' }}>ê°€ì…í•˜ê¸°</button>
              </form>
              <p>ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”? <a href="/login">ë¡œê·¸ì¸</a></p>
            </div>
          );
        };

        export default Register;
        EOF
        
        cat > src/components/Dashboard.js << 'EOF'
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { Line } from 'react-chartjs-2';
        import {
          Chart as ChartJS,
          CategoryScale,
          LinearScale,
          PointElement,
          LineElement,
          Title,
          Tooltip,
          Legend,
        } from 'chart.js';
        import { toast } from 'react-toastify';

        ChartJS.register(
          CategoryScale,
          LinearScale,
          PointElement,
          LineElement,
          Title,
          Tooltip,
          Legend
        );

        const Dashboard = () => {
          const [account, setAccount] = useState(null);
          const [priceData, setPriceData] = useState({ labels: [], datasets: [] });
          const token = localStorage.getItem('token');

          useEffect(() => {
            const fetchAccount = async () => {
              try {
                const response = await axios.get('/api/v1/account', {
                  headers: { Authorization: `Bearer ${token}` },
                });
                setAccount(response.data);
              } catch (error) {
                toast.error('ê³„ì¢Œ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨');
              }
            };

            const ws = new WebSocket('ws://localhost:8000/api/v1/ws/prices/BTCUSDT');
            ws.onmessage = (event) => {
              const data = JSON.parse(event.data);
              setPriceData((prev) => {
                const newLabels = [...prev.labels, new Date().toLocaleTimeString()];
                const newData = [...(prev.datasets[0]?.data || []), parseFloat(data.price)];
                return {
                  labels: newLabels.slice(-20),
                  datasets: [{
                    label: 'BTCUSDT Price',
                    data: newData.slice(-20),
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1
                  }]
                };
              });
            };

            fetchAccount();
            return () => ws.close();
          }, [token]);

          if (!account) return <div>ë¡œë”© ì¤‘...</div>;

          return (
            <div style={{ padding: '20px' }}>
              <h2>ëŒ€ì‹œë³´ë“œ</h2>
              <p>ì”ê³ : {account.balance}</p>
              <p>ì´ ìˆ˜ìµ: {account.total_profit}</p>
              <p>ìˆ˜ìµë¥ : {account.profit_rate}%</p>
              <h3>ì‹¤ì‹œê°„ BTCUSDT ê°€ê²© ì°¨íŠ¸</h3>
              <Line data={priceData} />
              <a href="/portfolio">í¬íŠ¸í´ë¦¬ì˜¤ ë³´ê¸°</a> | <a href="/order">ì£¼ë¬¸ í•˜ê¸°</a>
            </div>
          );
        };

        export default Dashboard;
        EOF
        
        cat > src/components/Portfolio.js << 'EOF'
        import React, { useState, useEffect } from 'react';
        import axios from 'axios';
        import { toast } from 'react-toastify';

        const Portfolio = () => {
          const [positions, setPositions] = useState([]);
          const token = localStorage.getItem('token');

          useEffect(() => {
            const fetchPortfolio = async () => {
              try {
                const response = await axios.get('/api/v1/account', {
                  headers: { Authorization: `Bearer ${token}` },
                });
                setPositions(response.data.positions);
              } catch (error) {
                toast.error('í¬íŠ¸í´ë¦¬ì˜¤ ë¡œë“œ ì‹¤íŒ¨');
              }
            };
            fetchPortfolio();
          }, [token]);

          return (
            <div style={{ padding: '20px' }}>
              <h2>í¬íŠ¸í´ë¦¬ì˜¤</h2>
              <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead>
                  <tr>
                    <th>ì‹¬ë³¼</th>
                    <th>ìˆ˜ëŸ‰</th>
                    <th>í‰ê·  ê°€ê²©</th>
                    <th>í˜„ì¬ ê°€ì¹˜</th>
                    <th>ë¯¸ì‹¤í˜„ ìˆ˜ìµ</th>
                  </tr>
                </thead>
                <tbody>
                  {positions.map((pos, index) => (
                    <tr key={index} style={{ borderBottom: '1px solid #ddd' }}>
                      <td>{pos.symbol}</td>
                      <td>{pos.quantity}</td>
                      <td>{pos.average_price}</td>
                      <td>{pos.current_value}</td>
                      <td style={{ color: pos.unrealized_profit > 0 ? 'green' : 'red' }}>{pos.unrealized_profit}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
              <a href="/dashboard">ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°</a>
            </div>
          );
        };

        export default Portfolio;
        EOF
        
        cat > src/components/OrderForm.js << 'EOF'
        import React, { useState } from 'react';
        import axios from 'axios';
        import { useNavigate } from 'react-router-dom';
        import { toast } from 'react-toastify';

        const OrderForm = () => {
          const [symbol, setSymbol] = useState('BTCUSDT');
          const [side, setSide] = useState('BUY');
          const [orderType, setOrderType] = useState('MARKET');
          const [quantity, setQuantity] = useState('');
          const [price, setPrice] = useState('');
          const token = localStorage.getItem('token');
          const navigate = useNavigate();

          const handleSubmit = async (e) => {
            e.preventDefault();
            try {
              await axios.post('/api/v1/orders', {
                symbol,
                side,
                order_type: orderType,
                quantity: parseFloat(quantity),
                price: orderType === 'LIMIT' ? parseFloat(price) : undefined
              }, {
                headers: { Authorization: `Bearer ${token}` },
              });
              toast.success('ì£¼ë¬¸ ì„±ê³µ!');
              navigate('/dashboard');
            } catch (error) {
              toast.error('ì£¼ë¬¸ ì‹¤íŒ¨: ' + (error.response?.data?.detail || 'ì˜¤ë¥˜ ë°œìƒ'));
            }
          };

          return (
            <div style={{ maxWidth: '400px', margin: 'auto', padding: '20px' }}>
              <h2>ì£¼ë¬¸ í•˜ê¸°</h2>
              <form onSubmit={handleSubmit}>
                <select value={symbol} onChange={(e) => setSymbol(e.target.value)} style={{ display: 'block', margin: '10px 0', width: '100%' }}>
                  <option>BTCUSDT</option>
                  <option>ETHUSDT</option>
                  <option>BNBUSDT</option>
                </select>
                <select value={side} onChange={(e) => setSide(e.target.value)} style={{ display: 'block', margin: '10px 0', width: '100%' }}>
                  <option>BUY</option>
                  <option>SELL</option>
                </select>
                <select value={orderType} onChange={(e) => setOrderType(e.target.value)} style={{ display: 'block', margin: '10px 0', width: '100%' }}>
                  <option>MARKET</option>
                  <option>LIMIT</option>
                </select>
                <input
                  type="number"
                  placeholder="ìˆ˜ëŸ‰"
                  value={quantity}
                  onChange={(e) => setQuantity(e.target.value)}
                  style={{ display: 'block', margin: '10px 0', width: '100%' }}
                />
                {orderType === 'LIMIT' && (
                  <input
                    type="number"
                    placeholder="ê°€ê²©"
                    value={price}
                    onChange={(e) => setPrice(e.target.value)}
                    style={{ display: 'block', margin: '10px 0', width: '100%' }}
                  />
                )}
                <button type="submit" style={{ width: '100%' }}>ì£¼ë¬¸ ì œì¶œ</button>
              </form>
              <a href="/dashboard">ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°</a>
            </div>
          );
        };

        export default OrderForm;
        EOF
        
        cat > src/index.js << 'EOF'
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import App from './App';

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
        EOF
        
        # Note: In production, build the frontend with 'npm run build' and serve from client/build
        
        # README.md ìƒì„± (UI/UX ë³´ì™„ ì„¤ëª… ì¶”ê°€, Celery optional, uvicorn only for basic run)
        cat > README.md << 'EOF'
        # BeenCoin - ì‹¤ì‹œê°„ ì•”í˜¸í™”í ëª¨ì˜íˆ¬ì í”Œë«í¼

        ## ğŸš€ ì£¼ìš” ê¸°ëŠ¥
        - ì•ˆì „í•œ íšŒì›ê°€ì…/ë¡œê·¸ì¸ (JWT ì¸ì¦, ë¹„ë°€ë²ˆí˜¸ í•´ì‹±)
        - ì§€ì› ì½”ì¸: BTCUSDT, ETHUSDT, BNBUSDT
        - ì£¼ë¬¸ ì‹œìŠ¤í…œ: ì‹œì¥ê°€/ì§€ì •ê°€, ë§¤ìˆ˜/ë§¤ë„ (Binance ì‹¤ì‹œê°„ ë°ì´í„° ê¸°ë°˜)
        - ì§€ì •ê°€ ì£¼ë¬¸: WebSocket ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ê°€ê²© ë„ë‹¬ ì‹œ ìë™ ì‹¤í–‰
        - í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬: í¬ì§€ì…˜, ë¯¸ì‹¤í˜„ ìˆ˜ìµ, ì´ ìˆ˜ìµë¥  ê³„ì‚°
        - ê±°ë˜ ë‚´ì—­ ì¡°íšŒ ë° ìˆ˜ìˆ˜ë£Œ ì ìš© (0.1%)
        - ì‹¤ì‹œê°„ ê°€ê²© ìŠ¤íŠ¸ë¦¬ë° (WebSocket /ws/prices/{symbol})
        - ë°°ê²½ ì‘ì—…: Celery + Redisë¡œ ì£¼ê¸°ì  í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ (ë§¤ 5ë¶„, optional)
        - í…ŒìŠ¤íŠ¸ ì½”ë“œ: pytest ê¸°ë°˜ unit tests
        - í”„ë¡ íŠ¸ì—”ë“œ UI/UX: React ê¸°ë°˜, ëª¨ë°”ì¼ ë°˜ì‘í˜• ëŒ€ì‹œë³´ë“œ, ì°¨íŠ¸ (Chart.js), ì£¼ë¬¸ í¼, í¬íŠ¸í´ë¦¬ì˜¤ í…Œì´ë¸”
        - UI/UX ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤: ê°„ë‹¨í•œ ë„¤ë¹„ê²Œì´ì…˜, ë°ì´í„° ì‹œê°í™”, í† ìŠ¤íŠ¸ ì•Œë¦¼, ë°˜ì‘í˜• ë””ìì¸

        ## âš¡ ë¹ ë¥¸ ì‹œì‘
        1. .env íŒŒì¼ ìƒì„± (.env.example ì°¸ì¡°, Binance API í‚¤ í•„ìˆ˜)
        2. ë°±ì—”ë“œ ì‹¤í–‰ (ê¸°ë³¸ ê¸°ëŠ¥ë§Œ):
           ```bash
           pip install -r requirements.txt
           uvicorn app.main:app --reload
